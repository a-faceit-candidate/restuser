package restuser

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// @title User Service REST API
// @version 1.0.0
// @description A simple user service for the FACEIT code challange.
// @termsOfService http://github.com/a-faceit-candidate/userservice

// @contact.name API Support
// @contact.url http://github.com/a-faceit-candidate/userservice
// @contact.email faceit@colega.eu

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @query.collection.format multi

// @BasePath /v1
const (
	defaultBasePath = "/v1"
	usersPath       = "/users"
)

type API struct {
	cfg        Config
	basePath   string
	httpClient *http.Client
}

type Config struct {
	URL string
}

// New creates a new API client
func New(config Config, options ...Option) *API {
	api := &API{
		cfg:        config,
		basePath:   defaultBasePath,
		httpClient: http.DefaultClient,
	}
	for _, opt := range options {
		opt(api)
	}
	return api
}

// Option configures the runtime specifics of the client.
type Option func(*API)

// WithBasePath configures the API to use a different base path, for whatever reason.
func WithBasePath(basePath string) Option {
	return func(api *API) {
		api.basePath = basePath
	}
}

// WithHTTPClient configures the API to use a specific http Client.
// Useful to make requests with authorization, or other headers, for instance.
func WithHTTPClient(client *http.Client) Option {
	return func(api *API) {
		api.httpClient = client
	}
}

// CreateUser creates a new user. The ID, CreatedAt and UpdatedAt fields should be empty.
// @Summary Create a new user.
// @Description The user provided should have the `id` field empty, as it will be generated by the service.
// @ID post-user
// @Accept json
// @Produce json
// @Success 201 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [post]
func (a *API) CreateUser(ctx context.Context, user *User) (*User, error) {
	if user == nil {
		return nil, fmt.Errorf("user can't be nil")
	}
	resp, err := a.doRequest(ctx, http.MethodPost, usersPath, user)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	switch resp.StatusCode {
	case http.StatusCreated:
		return a.unmarshalUserResponse(resp)
	case http.StatusBadRequest,
		http.StatusInternalServerError:
		return nil, a.unmarshalErrorResponse(resp)
	default:
		return nil, fmt.Errorf("received unexpected status code %d", resp.StatusCode)
	}
}

// UpdateUser updates an existing user.
// The ID, CreatedAt and UpdatedAt fields should not be updated when requested.
// @Summary Update a user with the given ID.
// @Description The `id`, `created_at` and `updated_at` fields should not be updated when requested.
// @ID put-user
// @Accept json
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} User
// @Failure 400 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Failure 409 {object} ErrorResponse "If UpdatedAt field doesn't match"
// @Failure 500 {object} ErrorResponse
// @Router /users/{id} [put]
func (a *API) UpdateUser(ctx context.Context, user *User) (*User, error) {
	if user == nil {
		return nil, fmt.Errorf("user can't be nil")
	}
	resp, err := a.doRequest(ctx, http.MethodPut, fmt.Sprintf("%s/%s", usersPath, user.ID), user)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	switch resp.StatusCode {
	case http.StatusOK:
		return a.unmarshalUserResponse(resp)
	case http.StatusBadRequest,
		http.StatusConflict,
		http.StatusNotFound,
		http.StatusInternalServerError:
		return nil, a.unmarshalErrorResponse(resp)
	default:
		return nil, fmt.Errorf("received unexpected status code %d", resp.StatusCode)
	}
}

// @Summary Delete a user by its ID.
// @ID delete-user
// @Produce json
// @Param id path string true "User ID"
// @Success 204
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id} [delete]
func (a *API) DeleteUser(ctx context.Context, id string) error {
	resp, err := a.doRequest(ctx, http.MethodDelete, fmt.Sprintf("%s/%s", usersPath, id), nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	switch resp.StatusCode {
	case http.StatusNoContent:
		return nil
	case http.StatusNotFound,
		http.StatusInternalServerError:
		return a.unmarshalErrorResponse(resp)
	default:
		return fmt.Errorf("received unexpected status code %d", resp.StatusCode)
	}
}

// GetUser retrieves a user by its ID.
// @Summary Retrieve a user by its ID.
// @ID get-user
// @Produce json
// @Param id path string true "User ID"
// @Success 200 {object} User
// @Failure 404 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users/{id} [get]
func (a *API) GetUser(ctx context.Context, id string) (*User, error) {
	resp, err := a.doRequest(ctx, http.MethodGet, fmt.Sprintf("%s/%s", usersPath, id), nil)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	switch resp.StatusCode {
	case http.StatusOK:
		return a.unmarshalUserResponse(resp)
	case http.StatusNotFound,
		http.StatusInternalServerError:
		return nil, a.unmarshalErrorResponse(resp)
	default:
		return nil, fmt.Errorf("received unexpected status code %d", resp.StatusCode)
	}
}

// ListUsers lists existing users with optional filters.
// @Summary List users.
// @Description List users, can be filtered by country code.
// @Description This operation does not return the PasswordHash and PasswordSalt fields for security reasons.
// @ID list-users
// @Produce json
// @Param country query string false "filter by country code"
// @Success 200 {array} User
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /users [get]
func (a *API) ListUsers(ctx context.Context, params ListUsersParams) ([]User, error) {
	req, err := a.request(ctx, http.MethodGet, usersPath, nil)
	if err != nil {
		return nil, err
	}

	if params.Country != "" {
		query := req.URL.Query()
		query.Add("country", params.Country)
		req.URL.RawQuery = query.Encode()
	}

	resp, err := a.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("can't perform http request: %w", err)
	}
	defer resp.Body.Close()

	switch resp.StatusCode {
	case http.StatusOK:
		var users []User
		if err := json.NewDecoder(resp.Body).Decode(&users); err != nil {
			return nil, fmt.Errorf("response was %d, however can't unmarshal users JSON: %w", resp.StatusCode, err)
		}
		return users, nil
	case http.StatusBadRequest,
		http.StatusInternalServerError:
		return nil, a.unmarshalErrorResponse(resp)
	default:
		return nil, fmt.Errorf("received unexpected status code %d", resp.StatusCode)
	}
}

// ListUsersParams configures the terms of user listing.
type ListUsersParams struct {
	// Country optionally filters the list by country code.
	Country string
}

func (a *API) doRequest(ctx context.Context, method, path string, user interface{}) (*http.Response, error) {
	req, err := a.request(ctx, method, path, user)
	if err != nil {
		return nil, err
	}
	resp, err := a.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("can't perform http request: %w", err)
	}
	return resp, nil
}

func (a *API) request(ctx context.Context, method, path string, payload interface{}) (*http.Request, error) {
	var body io.Reader
	if payload != nil {
		data, err := json.Marshal(payload)
		if err != nil {
			return nil, fmt.Errorf("can't marshal payload: %w", err)
		}
		body = bytes.NewReader(data)
	}
	url := a.cfg.URL + a.basePath + path
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, fmt.Errorf("can't build HTTP request: %w", err)
	}
	return req.WithContext(ctx), nil
}

func (a *API) unmarshalUserResponse(resp *http.Response) (*User, error) {
	var respUser User
	if err := json.NewDecoder(resp.Body).Decode(&respUser); err != nil {
		return nil, fmt.Errorf("response was %d, however can't unmarshal user JSON: %w", resp.StatusCode, err)
	}
	return &respUser, nil
}

func (a *API) unmarshalErrorResponse(resp *http.Response) error {
	var respError ErrorResponse
	if err := json.NewDecoder(resp.Body).Decode(&respError); err != nil {
		return fmt.Errorf("response was %d, however can't unmarshal error JSON: %w", resp.StatusCode, err)
	}
	return Error{
		StatusCode: resp.StatusCode,
		Response:   &respError,
	}
}

// Error is returned by client methods when API returns a non-success status code which is documented.
type Error struct {
	StatusCode int
	Response   *ErrorResponse
}

func (e Error) Error() string {
	if e.Response != nil {
		return fmt.Sprintf("userservice responded %d: %s", e.StatusCode, e.Response.Message)
	}
	return fmt.Sprintf("userservice responded %d", e.StatusCode)
}
